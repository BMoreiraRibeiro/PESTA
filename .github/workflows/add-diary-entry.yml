name: Adicionar Entrada ao Di√°rio T√©cnico

on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write

jobs:
  add-diary-entry:
    # S√≥ executa se a issue tiver o label "di√°rio"
    if: contains(github.event.issue.labels.*.name, 'di√°rio')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Parse Issue and Add to Diary
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const issue = context.payload.issue;
            const body = issue.body;
            
            // Extrair informa√ß√µes do issue body
            const extractField = (label) => {
              const regex = new RegExp(`### ${label}\\s*([\\s\\S]*?)(?=###|$)`, 'i');
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            };
            
            const title = extractField('üìå T√≠tulo da Entrada');
            const category = extractField('üè∑Ô∏è Categoria') || extractField('üè∑Ô∏è Tema / Assunto') || 'Gerais';
            const description = extractField('üìù Contexto') || extractField('ÔøΩ Descri√ß√£o');
            const notes = extractField('ÔøΩ Notas/Observa√ß√µes') || extractField('üí° Notas/Observa√ß√µes');
            
            // Obter data atual
            const date = new Date().toISOString().split('T')[0];
            
            // Construir entrada em Markdown
            let entry = `## [${date}] - ${title}\n\n`;
            entry += `**Categoria:** ${category}\n\n`;
            
            if (contextField && contextField !== '_No response_') {
              entry += `### Contexto\n${contextField}\n\n`;
            }
            
            if (description && description !== '_No response_') {
              entry += `### Descri√ß√£o\n${description}\n\n`;
            }

            if (notes && notes !== '_No response_') {
              entry += `### Notas/Observa√ß√µes\n${notes}\n\n`;
            }
            
            // Inserir nova entrada
            lines.splice(insertIndex, 0, '', entry);
            
            // Escrever de volta
            fs.writeFileSync(diaryPath, lines.join('\n'));
            
            console.log('Entrada adicionada com sucesso!');

      - name: Commit and Push
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add docs/technical_diary.md
          git commit -m "docs: adicionar entrada ao di√°rio [$(date +%Y-%m-%d)] [skip ci]"
          git push

      - name: Close Issue and Comment
        uses: actions/github-script@v7
        with:
          script: |
            const date = new Date().toISOString().split('T')[0];
            
            // Obter data atual
            const date = new Date().toISOString().split('T')[0];

            // Normalizar t√≠tulo para filename
            const slug = title.toLowerCase()
              .replace(/[^a-z0-9]+/g, '-')
              .replace(/(^-|-$)/g, '');

            // Diret√≥rio e caminho do novo ficheiro
            const entriesDir = 'docs/technical_diary_entries';
            fs.mkdirSync(entriesDir, { recursive: true });
            const filename = `${date}-${slug}.md`;
            const filePath = `${entriesDir}/${filename}`;

            // Construir conte√∫do do ficheiro com front-matter
            let fileContent = `---\n`;
            fileContent += `title: "[${date}] - ${title}"\n`;
            fileContent += `date: ${date}\n`;
            fileContent += `category: ${category}\n`;
            fileContent += `---\n\n`;
            fileContent += `# [${date}] - ${title}\n\n`;

            if (description && description !== '_No response_') {
              fileContent += `### Descri√ß√£o\n${description}\n\n`;
            }

            if (notes && notes !== '_No response_') {
              fileContent += `### Notas/Observa√ß√µes\n${notes}\n\n`;
            }

            fileContent += `---\n`;

            // Escrever novo ficheiro
            fs.writeFileSync(filePath, fileContent, 'utf8');

            // Atualizar √≠ndice (docs/technical_diary.md) adicionando link para a nova p√°gina
            const indexPath = 'docs/technical_diary.md';
            try {
              let indexContent = fs.readFileSync(indexPath, 'utf8');
              const indexLines = indexContent.split('\n');
              let insertIndex = 0;
              for (let i = 0; i < indexLines.length; i++) {
                if (indexLines[i].startsWith('# ')) {
                  insertIndex = i + 1;
                  while (insertIndex < indexLines.length && !indexLines[insertIndex].trim()) {
                    insertIndex++;
                  }
                  break;
                }
              }

              const relativePath = `technical_diary_entries/${filename}`;
              const linkLine = `- [${date} - ${title}](./${relativePath})`;
              indexLines.splice(insertIndex, 0, '', linkLine, '');
              fs.writeFileSync(indexPath, indexLines.join('\n'), 'utf8');
            } catch (err) {
              // Se o ficheiro index n√£o existir, ignorar
              console.log('N√£o foi poss√≠vel atualizar o √≠ndice:', err.message);
            }

            console.log('Entrada adicionada com sucesso como p√°gina individual!');
