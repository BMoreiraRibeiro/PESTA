name: Adicionar Entrada ao Di√°rio T√©cnico

on:
  issues:
    types: [opened]

permissions:
  contents: write
  issues: write
  actions: write

jobs:
  add-diary-entry:
    # S√≥ executa se a issue tiver o label "di√°rio"
    if: contains(github.event.issue.labels.*.name, 'di√°rio')
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Process Issue and Create Diary Page
        uses: actions/github-script@v7
        with:
          script: |
            const issue = context.payload.issue;
            const body = issue.body || '';
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            const extractField = (label) => {
              const regex = new RegExp(`### ${label}\\s*([\\s\\S]*?)(?=###|$)`, 'i');
              const match = body.match(regex);
              return match ? match[1].trim() : '';
            };

            const title = extractField('üìå T√≠tulo da Entrada') || '[sem t√≠tulo]';
            const category = extractField('üè∑Ô∏è Tema / Assunto') || extractField('üè∑Ô∏è Categoria') || 'Gerais';
            const description = extractField('üìù Descri√ß√£o') || extractField('üìù Contexto') || '';
            const notes = extractField('üí° Notas/Observa√ß√µes') || '';

            const date = new Date().toISOString().split('T')[0];
            const slugBase = title.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/(^-|-$)/g, '') || 'entry';

            // ensure unique filename (append counter if exists)
            let counter = 0;
            let filename;
            let filePath;
            while (true) {
              const suffix = counter === 0 ? '' : `-${counter}`;
              filename = `${date}-${slugBase}${suffix}.md`;
              filePath = `docs/technical_diary_entries/${filename}`;
              try {
                await github.rest.repos.getContent({ owner, repo, path: filePath });
                counter++;
              } catch (e) {
                // not found -> ok to use
                break;
              }
            }

            const frontMatter = `---\ntitle: "[${date}] - ${title}"\ndate: ${date}\ncategory: ${category}\n---\n\n`;
            let fileContent = frontMatter + `# [${date}] - ${title}\n\n`;
            if (description) fileContent += `### Descri√ß√£o\n${description}\n\n`;
            if (notes) fileContent += `### Notas/Observa√ß√µes\n${notes}\n\n`;
            fileContent += `---\n`;

            const contentBase64 = Buffer.from(fileContent, 'utf8').toString('base64');

            // create the file in the repo
            await github.rest.repos.createOrUpdateFileContents({
              owner,
              repo,
              path: filePath,
              message: `docs: adicionar entrada ao di√°rio ${date} - ${title} [skip ci]`,
              content: contentBase64,
              committer: { name: 'github-actions[bot]', email: 'github-actions[bot]@users.noreply.github.com' },
              author: { name: 'github-actions[bot]', email: 'github-actions[bot]@users.noreply.github.com' }
            });

            // try to update the index file with a link inside docs/technical_diary_entries/index.md
            const indexPath = 'docs/technical_diary_entries/index.md';
            try {
              const indexResp = await github.rest.repos.getContent({ owner, repo, path: indexPath });
              const indexSha = indexResp.data.sha;
              const indexContent = Buffer.from(indexResp.data.content, indexResp.data.encoding).toString('utf8');
              const indexLines = indexContent.split('\n');
              let insertIndex = 0;
              for (let i = 0; i < indexLines.length; i++) {
                if (indexLines[i].startsWith('# ')) {
                  insertIndex = i + 1;
                  while (insertIndex < indexLines.length && !indexLines[insertIndex].trim()) insertIndex++;
                  break;
                }
              }
              // since index.md is inside the same folder, link directly to the filename
              const linkLine = `- [${date} - ${title}](./${filename})`;
              indexLines.splice(insertIndex, 0, '', linkLine, '');
              const newIndexContent = indexLines.join('\n');
              const newIndexBase64 = Buffer.from(newIndexContent, 'utf8').toString('base64');
              await github.rest.repos.createOrUpdateFileContents({
                owner,
                repo,
                path: indexPath,
                message: `docs: adicionar link para entrada ${filename} [skip ci]`,
                content: newIndexBase64,
                sha: indexSha,
                committer: { name: 'github-actions[bot]', email: 'github-actions[bot]@users.noreply.github.com' },
                author: { name: 'github-actions[bot]', email: 'github-actions[bot]@users.noreply.github.com' }
              });
            } catch (err) {
              // if the index doesn't exist, create a new one with header + link
              try {
                const header = `# Di√°rio T√©cnico ‚Äî √çndice\n\n`;
                const newIndexContent = header + `- [${date} - ${title}](./${filename})\n`;
                const newIndexBase64 = Buffer.from(newIndexContent, 'utf8').toString('base64');
                await github.rest.repos.createOrUpdateFileContents({
                  owner,
                  repo,
                  path: indexPath,
                  message: `docs: criar √≠ndice do di√°rio e adicionar ${filename} [skip ci]`,
                  content: newIndexBase64,
                  committer: { name: 'github-actions[bot]', email: 'github-actions[bot]@users.noreply.github.com' },
                  author: { name: 'github-actions[bot]', email: 'github-actions[bot]@users.noreply.github.com' }
                });
              } catch (err2) {
                core && core.info && core.info(`√çndice n√£o atualizado: ${err.message}; cria√ß√£o falhou: ${err2.message}`);
              }
            }

            // Comment and close the issue
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: issue.number,
              body: `‚úÖ **Entrada adicionada ao di√°rio t√©cnico!**\n\nüìÖ Data: ${date}\n\nüîó [Ver p√°gina](https://github.com/${owner}/${repo}/blob/master/${filePath})`
            });

            await github.rest.issues.update({
              owner,
              repo,
              issue_number: issue.number,
              state: 'closed'
            });

            // Trigger the deploy workflow explicitly so the site is published
            try {
              await github.rest.actions.createWorkflowDispatch({
                owner,
                repo,
                workflow_id: 'deploy-mkdocs.yml',
                ref: 'master'
              });
            } catch (dispatchErr) {
              core && core.info && core.info(`Falha ao disparar workflow de deploy: ${dispatchErr.message}`);
            }
